{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport axios from 'axios';\nimport Cookies from '@/lib/cookies';\nimport getTimeZone from '@/utils/getTimeZone';\nconst api = axios.create({\n  baseURL: process.env.NEXT_PUBLIC_API_URL\n});\napi.defaults.headers['User-TimeZone'] = getTimeZone();\napi.interceptors.request.use(config => {\n  const session = Cookies.get('session');\n\n  if (session === null || session === void 0 ? void 0 : session.access_token) {\n    config.headers.Authorization = `Bearer ${session.access_token}`;\n  }\n\n  return config;\n}, error => {\n  Promise.reject(error);\n});\napi.interceptors.response.use(response => response, error => {\n  const request = error.config;\n\n  const isFrom = from => request.url.includes(from);\n\n  const isMethod = method => request.method.toUpperCase() === method;\n\n  const isStatusCode = statusCode => error.response && error.response.status === statusCode;\n\n  if (isFrom('sessions') && !isMethod('PUT')) {\n    return Promise.reject(error);\n  }\n\n  const session = Cookies.get('session');\n\n  if (!session || !isStatusCode(200) && isFrom('sessions') && isMethod('PUT')) {\n    Cookies.remove('session');\n    window.location.href = '/';\n    return Promise.reject(error);\n  }\n\n  if (isStatusCode(401) && !request._retry) {\n    request._retry = true;\n    return api.put('sessions', {\n      token: session.refresh_token\n    }).then(response => {\n      const {\n        access_token\n      } = response.data;\n      Cookies.set('session', _objectSpread(_objectSpread({}, session), {}, {\n        access_token\n      }));\n      api.defaults.headers.common.Authorization = `Bearer ${access_token}`;\n      return api(request);\n    });\n  }\n\n  return Promise.reject(error);\n});\nexport default api;","map":{"version":3,"sources":["/home/matheus/Documents/drive-sync/Projects/endor/packages/web/src/services/api.ts"],"names":["axios","Cookies","getTimeZone","api","create","baseURL","process","env","NEXT_PUBLIC_API_URL","defaults","headers","interceptors","request","use","config","session","get","access_token","Authorization","error","Promise","reject","response","isFrom","from","url","includes","isMethod","method","toUpperCase","isStatusCode","statusCode","status","remove","window","location","href","_retry","put","token","refresh_token","then","data","set","common"],"mappings":";;;;;;AAAA,OAAOA,KAAP,MAAkB,OAAlB;AAEA,OAAOC,OAAP,MAAoB,eAApB;AACA,OAAOC,WAAP,MAAwB,qBAAxB;AAWA,MAAMC,GAAG,GAAGH,KAAK,CAACI,MAAN,CAAa;AACvBC,EAAAA,OAAO,EAAEC,OAAO,CAACC,GAAR,CAAYC;AADE,CAAb,CAAZ;AAIAL,GAAG,CAACM,QAAJ,CAAaC,OAAb,CAAqB,eAArB,IAAwCR,WAAW,EAAnD;AAEAC,GAAG,CAACQ,YAAJ,CAAiBC,OAAjB,CAAyBC,GAAzB,CACEC,MAAM,IAAI;AACR,QAAMC,OAAO,GAAGd,OAAO,CAACe,GAAR,CAAsB,SAAtB,CAAhB;;AAEA,MAAID,OAAJ,aAAIA,OAAJ,uBAAIA,OAAO,CAAEE,YAAb,EAA2B;AACzBH,IAAAA,MAAM,CAACJ,OAAP,CAAeQ,aAAf,GAAgC,UAASH,OAAO,CAACE,YAAa,EAA9D;AACD;;AAED,SAAOH,MAAP;AACD,CATH,EAUEK,KAAK,IAAI;AACPC,EAAAA,OAAO,CAACC,MAAR,CAAeF,KAAf;AACD,CAZH;AAeAhB,GAAG,CAACQ,YAAJ,CAAiBW,QAAjB,CAA0BT,GAA1B,CACES,QAAQ,IAAIA,QADd,EAEEH,KAAK,IAAI;AACP,QAAMP,OAAO,GAAGO,KAAK,CAACL,MAAtB;;AAEA,QAAMS,MAAM,GAAIC,IAAD,IAA2BZ,OAAO,CAACa,GAAR,CAAYC,QAAZ,CAAqBF,IAArB,CAA1C;;AAEA,QAAMG,QAAQ,GACZC,MADe,IAEHhB,OAAO,CAACgB,MAAR,CAAeC,WAAf,OAAiCD,MAF/C;;AAIA,QAAME,YAAY,GAAIC,UAAD,IACnBZ,KAAK,CAACG,QAAN,IAAkBH,KAAK,CAACG,QAAN,CAAeU,MAAf,KAA0BD,UAD9C;;AAGA,MAAIR,MAAM,CAAC,UAAD,CAAN,IAAsB,CAACI,QAAQ,CAAC,KAAD,CAAnC,EAA4C;AAC1C,WAAOP,OAAO,CAACC,MAAR,CAAeF,KAAf,CAAP;AACD;;AAED,QAAMJ,OAAO,GAAGd,OAAO,CAACe,GAAR,CAAsB,SAAtB,CAAhB;;AAEA,MACE,CAACD,OAAD,IACC,CAACe,YAAY,CAAC,GAAD,CAAb,IAAsBP,MAAM,CAAC,UAAD,CAA5B,IAA4CI,QAAQ,CAAC,KAAD,CAFvD,EAGE;AACA1B,IAAAA,OAAO,CAACgC,MAAR,CAAe,SAAf;AACAC,IAAAA,MAAM,CAACC,QAAP,CAAgBC,IAAhB,GAAuB,GAAvB;AAEA,WAAOhB,OAAO,CAACC,MAAR,CAAeF,KAAf,CAAP;AACD;;AAED,MAAIW,YAAY,CAAC,GAAD,CAAZ,IAAqB,CAAClB,OAAO,CAACyB,MAAlC,EAA0C;AACxCzB,IAAAA,OAAO,CAACyB,MAAR,GAAiB,IAAjB;AAEA,WAAOlC,GAAG,CACPmC,GADI,CACwB,UADxB,EACoC;AACvCC,MAAAA,KAAK,EAAExB,OAAO,CAACyB;AADwB,KADpC,EAIJC,IAJI,CAICnB,QAAQ,IAAI;AAChB,YAAM;AAAEL,QAAAA;AAAF,UAAmBK,QAAQ,CAACoB,IAAlC;AAEAzC,MAAAA,OAAO,CAAC0C,GAAR,CAAY,SAAZ,kCAA4B5B,OAA5B;AAAqCE,QAAAA;AAArC;AAEAd,MAAAA,GAAG,CAACM,QAAJ,CAAaC,OAAb,CAAqBkC,MAArB,CAA4B1B,aAA5B,GAA6C,UAASD,YAAa,EAAnE;AAEA,aAAOd,GAAG,CAACS,OAAD,CAAV;AACD,KAZI,CAAP;AAaD;;AAED,SAAOQ,OAAO,CAACC,MAAR,CAAeF,KAAf,CAAP;AACD,CAjDH;AAoDA,eAAehB,GAAf","sourcesContent":["import axios from 'axios';\n\nimport Cookies from '@/lib/cookies';\nimport getTimeZone from '@/utils/getTimeZone';\n\ninterface ISession {\n  access_token: string;\n  refresh_token: string;\n}\n\ninterface IUpdateSessionResponse {\n  access_token: string;\n}\n\nconst api = axios.create({\n  baseURL: process.env.NEXT_PUBLIC_API_URL,\n});\n\napi.defaults.headers['User-TimeZone'] = getTimeZone();\n\napi.interceptors.request.use(\n  config => {\n    const session = Cookies.get<ISession>('session');\n\n    if (session?.access_token) {\n      config.headers.Authorization = `Bearer ${session.access_token}`;\n    }\n\n    return config;\n  },\n  error => {\n    Promise.reject(error);\n  },\n);\n\napi.interceptors.response.use(\n  response => response,\n  error => {\n    const request = error.config;\n\n    const isFrom = (from: string): boolean => request.url.includes(from);\n\n    const isMethod = (\n      method: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE',\n    ): boolean => request.method.toUpperCase() === method;\n\n    const isStatusCode = (statusCode: number) =>\n      error.response && error.response.status === statusCode;\n\n    if (isFrom('sessions') && !isMethod('PUT')) {\n      return Promise.reject(error);\n    }\n\n    const session = Cookies.get<ISession>('session');\n\n    if (\n      !session ||\n      (!isStatusCode(200) && isFrom('sessions') && isMethod('PUT'))\n    ) {\n      Cookies.remove('session');\n      window.location.href = '/';\n\n      return Promise.reject(error);\n    }\n\n    if (isStatusCode(401) && !request._retry) {\n      request._retry = true;\n\n      return api\n        .put<IUpdateSessionResponse>('sessions', {\n          token: session.refresh_token,\n        })\n        .then(response => {\n          const { access_token } = response.data;\n\n          Cookies.set('session', { ...session, access_token });\n\n          api.defaults.headers.common.Authorization = `Bearer ${access_token}`;\n\n          return api(request);\n        });\n    }\n\n    return Promise.reject(error);\n  },\n);\n\nexport default api;\n"]},"metadata":{},"sourceType":"module"}